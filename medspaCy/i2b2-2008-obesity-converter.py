import argparse
import glob
import os
import re

from tqdm import tqdm

import spacy
import medspacy
import cassis

from libTypeSystem import metadata_typeString, umlsConcept_typeString

from lxml import etree as ET

def main( args ):
    teams = [ os.path.basename( f ) for f in glob.glob( os.path.join( args.inputSysDir ,
                                                                      '*' ) ) ]
    for team in sorted( teams ):
        print( '{}'.format( team ) )
    
    ############################
    ## Load an clinical English medspaCy model trained on i2b2 data
    ## - https://github.com/medspacy/sectionizer/blob/master/notebooks/00-clinical_sectionizer.ipynb
    nlp_pipeline = spacy.load( 'en_info_3700_i2b2_2012' )
    ############################
    ## Create a type system
    ## - https://github.com/dkpro/dkpro-cassis/blob/master/cassis/typesystem.py
    ############
    ## ... for tokens
    typesystem = cassis.TypeSystem()
    TokenAnnotation = typesystem.create_type( name = 'uima.tt.TokenAnnotation' , 
                                              supertypeName = 'uima.tcas.Annotation' )
    typesystem.add_feature( type_ = TokenAnnotation ,
                            name = 'text' , 
                            rangeTypeName = 'uima.cas.String' )
    ############
    ## ... for Metadata
    ## TODO - this parent and supertype should probably be something else
    NoteMetadata = typesystem.create_type( name = metadata_typeString ,
                                           supertypeName = 'uima.tcas.Annotation' )
    ## TODO - how to represent pairs, as per the reference standard?
    typesystem.add_feature( type_ = NoteMetadata ,
                            name = 'other' ,
                            description = '' ,
                            rangeTypeName = 'uima.cas.String' )
    ############
    ## ... for UmlsConcept
    UmlsConcept = typesystem.create_type( name = umlsConcept_typeString ,
                                          supertypeName = 'uima.tcas.Annotation' )
    typesystem.add_feature( type_ = UmlsConcept ,
                            name = 'tui' ,
                            description = '' ,
                            rangeTypeName = 'uima.cas.String' )
    typesystem.add_feature( type_ = UmlsConcept ,
                            name = 'cui' ,
                            description = '' ,
                            rangeTypeName = 'uima.cas.String' )
    ############
    ## ... for IdentifiedAnnotation
    IdentifiedAnnotation = typesystem.create_type( name = 'textsem.IdentifiedAnnotation' ,
                                                   supertypeName = 'uima.tcas.Annotation' )
    typesystem.add_feature( type_ = IdentifiedAnnotation ,
                            name = 'polarity' ,
                            description = 'Default value of 0. Set to 1 when specifically asserted/positive and -1 when the annotation is "stated with negation"' ,
                            rangeTypeName = 'uima.cas.Integer' )
    typesystem.add_feature( type_ = IdentifiedAnnotation ,
                            name = 'uncertainty' ,
                            description = 'A 1 for when the annotation is "stated with doubt"; otherwise a 0' ,
                            rangeTypeName = 'uima.cas.Integer' )
    typesystem.add_feature( type_ = IdentifiedAnnotation ,
                            name = 'ontologyConceptArray' ,
                            description = 'The xmi:id of the array of ontology concepts associated with this annotation' ,
                            rangeTypeName = 'uima.cas.Integer' )
    typesystem.add_feature( type_ = IdentifiedAnnotation ,
                            name = 'discoveryTechnique' ,
                            description = 'The index of the discovery technique (or classifier) that produced this annotation' ,
                            rangeTypeName = 'uima.cas.Integer' )
    typesystem.add_feature( type_ = IdentifiedAnnotation ,
                            name = 'confidence' ,
                            description = 'A confidence score [0-1] generated by the discoveryTechnique when generating producing this annotation' ,
                            rangeTypeName = 'uima.cas.Double' )
    ############################
    ## Iterate over the files, covert to CAS, and write the XMI to disk
    classifier_votes = {}
    ## Loop over the reference standard
    input_tree = ET.parse( args.inputRefXml )
    input_root = input_tree.getroot()
    for node in input_root:
        ## Skipping 'intuitive' values for now
        if( node.attrib[ 'source' ] != 'textual' ):
            continue
        for disease_node in node:
            problem = disease_node.attrib[ 'name' ]
            for doc_node in disease_node:
                doc_id = doc_node.attrib[ 'id' ]
                judgment = doc_node.attrib[ 'judgment' ]
                if( doc_id not in classifier_votes ):
                    classifier_votes[ doc_id ] = {}
                if( 'Oracle' not in classifier_votes[ doc_id ] ):
                    classifier_votes[ doc_id ][ 'Oracle' ] = {}
                classifier_votes[ doc_id ][ 'Oracle' ][ problem ] = judgment
    ## Loop over the individual classifier judgments
    for team_filename in sorted( teams ):
        input_tree = ET.parse( os.path.join( args.inputSysDir , team_filename ) )
        input_root = input_tree.getroot()
        for node in input_root:
            ## Skipping 'intuitive' values for now
            if( node.attrib[ 'source' ] != 'textual' ):
                continue
            for disease_node in node:
                problem = disease_node.attrib[ 'name' ]
                for doc_node in disease_node:
                    doc_id = doc_node.attrib[ 'id' ]
                    judgment = doc_node.attrib[ 'judgment' ]
                    if( doc_id not in classifier_votes ):
                        classifier_votes[ doc_id ] = {}
                    if( team_filename not in classifier_votes[ doc_id ] ):
                        classifier_votes[ doc_id ][ team_filename ] = {}
                    classifier_votes[ doc_id ][ team_filename ][ problem ] = judgment
    ####
    input_tree = ET.parse( args.inputTextXml )
    input_root = input_tree.getroot()
    ##
    for node in input_root:
        for doc_node in tqdm( node ):
            doc_id = doc_node.attrib[ 'id' ]
            for text_node in doc_node:
                note_contents = text_node.text
                ##
                cas = cassis.Cas( typesystem = typesystem )
                cas.sofa_string = '\n'.join( note_contents )
                cas.sofa_mime = "text/plain"
                ##TODO - pre-process the notes
                ##sectionized_note = nlp_pipeline( cas.sofa_string )
                ##
                team_id = 0
                cas.add_annotation( NoteMetadata( other = '{}={}'.format( 'Oracle' , team_id ) ) )
                for team in sorted( teams ):
                    team_id += 1
                    if( team in classifier_votes[ doc_id ] ):
                        cas.add_annotation( NoteMetadata( other = '{}={}'.format( team , team_id ) ) )
                ####
                discTech = '0'
                for problem in classifier_votes[ doc_id ][ 'Oracle' ]:
                    judgment = classifier_votes[ doc_id ][ 'Oracle' ][ problem ]
                    polarity = 0
                    if( judgment == 'U' ):
                        ## Don't bother adding an annotation for unmentioned concepts
                        continue
                    elif( judgment == 'Q' ):
                        identified_annotation = IdentifiedAnnotation( begin = '0' ,
                                                                      end = '0' ,
                                                                      polarity = polarity ,
                                                                      uncertainty = '1' ,
                                                                      ## TODO - convert this to a standard UMLS CUI
                                                                      ontologyConceptArray = problem ,
                                                                      discoveryTechnique = '0' )
                    else:
                        if( judgment == 'N' ):
                            polarity = -1
                        elif( judgment == 'Y' ):
                            polarity = 1
                        identified_annotation = IdentifiedAnnotation( begin = '0' ,
                                                                      end = '0' ,
                                                                      polarity = polarity ,
                                                                      uncertainty = '0' ,
                                                                      ## TODO - convert this to a standard UMLS CUI
                                                                      ontologyConceptArray = problem ,
                                                                      discoveryTechnique = '0' )
                    cas.add_annotation( identified_annotation )
                team_id = 0
                for team in sorted( teams ):
                    team_id += 1
                    if( team in classifier_votes[ doc_id ] ):
                        for problem in classifier_votes[ doc_id ][ team ]:
                            judgment = classifier_votes[ doc_id ][ team ][ problem ]
                            polarity = 0
                            if( judgment == 'U' ):
                                ## Don't bother adding an annotation for unmentioned concepts
                                continue
                            elif( judgment == 'Q' ):
                                identified_annotation = IdentifiedAnnotation( begin = '0' ,
                                                                              end = '0' ,
                                                                              polarity = polarity ,
                                                                              uncertainty = '1' ,
                                                                              ## TODO - convert this to a standard UMLS CUI
                                                                              ontologyConceptArray = problem ,
                                                                              discoveryTechnique = team_id )

                            else:
                                if( judgment == 'N' ):
                                    polarity = -1
                                elif( judgment == 'Y' ):
                                    polarity = 1
                                identified_annotation = IdentifiedAnnotation( begin = '0' ,
                                                                              end = '0' ,
                                                                              polarity = polarity ,
                                                                              uncertainty = '0' ,
                                                                              ## TODO - convert this to a standard UMLS CUI
                                                                              ontologyConceptArray = problem ,
                                                                              discoveryTechnique = team_id )
                            cas.add_annotation( identified_annotation )
                ####
                xmi_filename = '{}.xmi'.format( doc_id )
                cas.to_xmi( path = os.path.join( args.outputDir , xmi_filename ) ,
                            pretty_print = True )


if __name__ == '__main__':
    parser = argparse.ArgumentParser( description = 'Simple spaCy pipeline for converting i2b2 2008 obesity challenge data to CAS XMI files with a SHARP-n schema' )
    parser.add_argument( '--input-text' ,
                         dest = 'inputTextXml' ,
                         help = 'Input XML file containing the body of the notes' )
    parser.add_argument( '--input-ref' ,
                         dest = 'inputRefXml' ,
                         help = 'Input XML file containing reference standard' )
    parser.add_argument( '--input-systems' ,
                         dest = 'inputSysDir' ,
                         help = 'Input directory containing the XML outputs of each classifier' )
    parser.add_argument( '--output-dir' ,
                         dest = 'outputDir' ,
                         help = 'Output directory for writing CAS XMI files to' )
    args = parser.parse_args()
    if( not os.path.exists( args.outputDir ) ):
        try:
            os.makedirs( args.outputDir )
        except OSError as e:
            log.error( 'OSError caught while trying to create output folder:  {}'.format( e ) )
        except IOError as e:
            log.error( 'IOError caught while trying to create output folder:  {}'.format( e ) )
    main( args )
